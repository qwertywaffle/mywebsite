<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>audio to image and vice versa</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#000;--accent:#00ff88;--panel:#001f1a}
    body { background:var(--bg); color:var(--accent); font-family:'Courier New',monospace; margin:0; padding:20px; }
    h1{margin:0 0 8px}
    .wrap { display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
    .pane { flex:1 1 420px; background:var(--panel); border:1px solid var(--accent); padding:14px; box-sizing:border-box; }
    label, select, input, button, a { display:block; margin:8px 0; color:var(--accent); background:transparent; border:1px solid var(--accent); padding:8px; font-family:inherit; }
    #logLeft,#logRight { white-space:pre-wrap; background:#00000010; border:1px solid var(--accent); padding:8px; height:220px; overflow:auto; font-size:12px; }
    button { cursor:pointer; }
    .row { display:flex; gap:8px; align-items:center; }
    canvas { display:none; }
    .metaSmall { font-size:12px; color:#88ffbb88; margin-top:6px; }
  </style>
</head>
<body>
<div class="wrap">
  <!-- LEFT: Audio → Image -->
  <div class="pane" id="leftPane">
    <h2>audio to image</h2>
    <input id="audioInput" type="file" accept="audio/*">
    <label>sample rate
      <select id="srSelectLeft">
        <option>8000</option>
        <option>16000</option>
        <option>22050</option>
        <option>44100</option>
        <option>48000</option>
        <option>96000</option>
      </select>
    </label>
    <label>bit depth
      <select id="bdSelectLeft">
        <option value="4">4 (quantized) (small)</option>
        <option value="8">8 (μ-law) (kinda big)</option>
        <option value="16">16 (linear PCM) (VERY LARGE)</option>
      </select>
    </label>
    <div class="row">
      <button id="encodeBtn">convert → image</button>
      <a id="downloadImg" style="display:none" download>download image</a>
    </div>
    <div id="logLeft"></div>
  </div>

  <!-- RIGHT: Image → Audio -->
  <div class="pane" id="rightPane">
    <h2>image to audio</h2>
    <input id="imageInput" type="file" accept="image/*">
    <label>sample rate (might be ignored if embedded)
      <select id="srSelectRight">
        <option>8000</option>
        <option>16000</option>
        <option>22050</option>
        <option selected>44100</option>
        <option>48000</option>
        <option>96000</option>
      </select>
    </label>
    <div class="row">
      <button id="decodeBtn">decode & play</button>
      <a id="downloadWav" style="display:none" download>download wav</a>
    </div>
    <div id="logRight"></div>

    <!-- OSCILLOSCOPE canvas -->
    <canvas id="oscilloscope" width="550" height="150" style="border:1px solid var(--accent); margin-top:10px; display:block;"></canvas>
  </div>
</div>

<canvas id="workCanvas"></canvas>

<script>
/* ================= utilities & UI logs ================= */
const logLeft = msg => { const el=document.getElementById('logLeft'); console.log(msg); el.textContent+= msg + '\n'; el.scrollTop = el.scrollHeight; };
const logRight = msg => { const el=document.getElementById('logRight'); console.log(msg); el.textContent+= msg + '\n'; el.scrollTop = el.scrollHeight; };
function writeUint32BE(arr, offset, value){
  arr[offset] = (value >>> 24) & 0xFF;
  arr[offset+1] = (value >>> 16) & 0xFF;
  arr[offset+2] = (value >>> 8) & 0xFF;
  arr[offset+3] = value & 0xFF;
}
function readUint32BE(arr, offset){
  return ((arr[offset] << 24) >>> 0) + (arr[offset+1] << 16) + (arr[offset+2] << 8) + arr[offset+3];
}

/* ================= µ-law companding ================= */
function linearToMuLawByte(x){
  const mu = 255;
  const sign = x < 0 ? -1 : 1;
  const absx = Math.min(1, Math.abs(x));
  const y = Math.log(1 + mu * absx) / Math.log(1 + mu);
  const comp = sign * y;
  return Math.round((comp * 0.5 + 0.5) * 255) & 0xFF;
}
function muLawByteToLinear(b){
  const mu = 255;
  const comp = (b / 255) * 2 - 1;
  const sign = comp < 0 ? -1 : 1;
  const absC = Math.abs(comp);
  const x = (Math.pow(1 + mu, absC) - 1) / mu;
  return Math.max(-1, Math.min(1, sign * x));
}

/* ================= delta & RLE ================= */
function deltaEncode(bytes){
  const out = new Uint8Array(bytes.length);
  let prev = 128;
  for(let i=0;i<bytes.length;i++){
    out[i] = (bytes[i] - prev) & 0xFF;
    prev = bytes[i];
  }
  return out;
}
function deltaDecode(bytes){
  const out = new Uint8Array(bytes.length);
  let prev = 128;
  for(let i=0;i<bytes.length;i++){
    const val = (prev + bytes[i]) & 0xFF;
    out[i] = val;
    prev = val;
  }
  return out;
}
function rleEncode(bytes){
  const out = [];
  let i=0;
  while(i<bytes.length){
    const v = bytes[i];
    let count = 1;
    while(i+count < bytes.length && bytes[i+count] === v && count < 255) count++;
    out.push(count, v);
    i += count;
  }
  return new Uint8Array(out);
}
function rleDecode(bytes){
  const out = [];
  for(let i=0;i<bytes.length;i+=2){
    const count = bytes[i];
    const val = bytes[i+1];
    for(let k=0;k<count;k++) out.push(val);
  }
  return new Uint8Array(out);
}

/* ================= WAV export ================= */
function floatTo16BitPCM(float32Array){
  const buffer = new ArrayBuffer(float32Array.length * 2);
  const view = new DataView(buffer);
  let offset = 0;
  for(let i=0;i<float32Array.length;i++,offset+=2){
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return buffer;
}
function createWavBlob(samplesFloat32, sampleRate, channels=1){
  const bytesPerSample = 2;
  const blockAlign = bytesPerSample * channels;
  const byteRate = sampleRate * blockAlign;
  const dataSize = samplesFloat32.length * bytesPerSample;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  function writeString(offset, s){ for(let i=0;i<s.length;i++) view.setUint8(offset+i, s.charCodeAt(i)); }
  writeString(0,'RIFF'); view.setUint32(4, 36 + dataSize, true);
  writeString(8,'WAVE'); writeString(12,'fmt '); view.setUint32(16,16,true);
  view.setUint16(20,1,true); view.setUint16(22,channels,true);
  view.setUint32(24,sampleRate,true); view.setUint32(28,byteRate,true);
  view.setUint16(32,blockAlign,true); view.setUint16(34,bytesPerSample*8,true);
  writeString(36,'data'); view.setUint32(40,dataSize,true);
  const pcm = new Uint8Array(floatTo16BitPCM(samplesFloat32));
  new Uint8Array(buffer,44).set(pcm);
  return new Blob([buffer], {type:'audio/wav'});
}

/* ================= CORE: ENCODE ================= */
async function encodeAudioFileToImage(file, bitDepth, targetSR){
  logLeft(`📥 selected: ${file.name} (${Math.round(file.size/1024)} KB)`);
  const ab = await file.arrayBuffer();
  const decodedCtx = new (window.AudioContext || window.webkitAudioContext)();
  const decBuf = await decodedCtx.decodeAudioData(ab);

  const offline = new OfflineAudioContext(1, Math.ceil(decBuf.duration * targetSR), targetSR);
  const src = offline.createBufferSource();
  src.buffer = decBuf;
  src.connect(offline.destination);
  src.start(0);
  const rendered = await offline.startRendering();

  const frames = rendered.length;
  const mono = new Float32Array(frames);
  if(rendered.numberOfChannels > 1){
    const L = rendered.getChannelData(0), R = rendered.getChannelData(1);
    for(let i=0;i<frames;i++) mono[i] = 0.5*(L[i]+R[i]);
  }else{
    mono.set(rendered.getChannelData(0));
  }

  let bytes;
  if(bitDepth===4){
    bytes=new Uint8Array(Math.ceil(frames/2));
    for(let i=0;i<frames;i++){
      const q = Math.round((mono[i]*0.5+0.5)*15)&0x0F;
      if(i%2===0) bytes[i>>1] = q<<4;
      else bytes[i>>1] |= q;
    }
  } else if(bitDepth===8){
    bytes=new Uint8Array(frames);
    for(let i=0;i<frames;i++) bytes[i]=linearToMuLawByte(mono[i]);
  } else if(bitDepth===12){
    bytes=new Uint8Array(frames*2);
    for(let i=0;i<frames;i++){
      const q=Math.round((mono[i]*0.5+0.5)*4095)&0x0FFF;
      bytes[i*2]=(q>>>8)&0xFF;
      bytes[i*2+1]=q&0xFF;
    }
  } else { //16-bit
    bytes=new Uint8Array(frames*2);
    for(let i=0;i<frames;i++){
      const s=Math.max(-1, Math.min(1, mono[i]));
      const val=s<0?Math.round(s*0x8000)&0xFFFF:Math.round(s*0x7FFF)&0xFFFF;
      bytes[i*2]=(val>>>8)&0xFF;
      bytes[i*2+1]=val&0xFF;
    }
  }

  const rle=rleEncode(deltaEncode(bytes));

  const header=new Uint8Array(8);
  header[0]=(targetSR>>>16)&0xFF;
  header[1]=(targetSR>>>8)&0xFF;
  header[2]=targetSR&0xFF;
  const bitCode=bitDepth===4?3:bitDepth===8?0:bitDepth===12?1:2;
  header[3]=((bitCode&0xF)<<4)|1;
  writeUint32BE(header,4,frames);

  const payload=new Uint8Array(header.length+rle.length);
  payload.set(header,0);
  payload.set(rle,header.length);

  const pixelCount=Math.ceil(payload.length/3)+2;
  const side=Math.ceil(Math.sqrt(pixelCount));
  const totalPixels=side*side;
  const out=new Uint8ClampedArray(totalPixels*4);
  for(let i=0;i<totalPixels;i++) out[i*4+3]=255;
  let p=0;
  for(let i=0;i<totalPixels;i++){
    const base=i*4;
    out[base+0]=payload[p++]||0;
    out[base+1]=payload[p++]||0;
    out[base+2]=payload[p++]||0;
  }

  const canvas=document.getElementById('workCanvas');
  canvas.width=side;canvas.height=side;
  canvas.getContext('2d').putImageData(new ImageData(out,side,side),0,0);

  const blob=await new Promise(r=>canvas.toBlob(r,'image/png',1));
  logLeft(`🖼 image size: ${side} x ${side}, png ≈ ${Math.round(blob.size/1024)} KB`);
  return blob;
}

/* ================= CORE: DECODE & OSCILLOSCOPE ================= */
async function decodeImageToAudio(imgFile){
  logRight(`📥 selected: ${imgFile.name} (${Math.round(imgFile.size/1024)} KB)`);
  const img=new Image();
  const url=URL.createObjectURL(imgFile);
  await new Promise(r=>{img.onload=r;img.src=url;});

  const canvas=document.getElementById('workCanvas');
  canvas.width=img.width;canvas.height=img.height;
  const ctx=canvas.getContext('2d');
  ctx.drawImage(img,0,0);
  const data=ctx.getImageData(0,0,img.width,img.height).data;

  const payload=[];
  for(let i=0;i<data.length;i+=4) payload.push(data[i],data[i+1],data[i+2]);
  const arr=new Uint8Array(payload);

  const sr=((arr[0]<<16)|(arr[1]<<8)|arr[2])>>>0||44100;
  const flags=arr[3]||0;
  const bitCode=(flags>>>4)&0xF;
  let bitDepth;
  if(bitCode===0) bitDepth=8;
  else if(bitCode===1) bitDepth=12;
  else if(bitCode===2) bitDepth=16;
  else if(bitCode===3) bitDepth=4;

  const sampleCount=readUint32BE(arr,4)||0;
  const compressed=arr.slice(8);
  const quantBytes=deltaDecode(rleDecode(compressed));

  let samples;
  if(bitDepth===4){
    samples = new Float32Array(sampleCount);
    for(let i=0;i<sampleCount;i++){
      const byte = quantBytes[i>>1];
      const q = (i%2===0) ? (byte>>4)&0x0F : byte&0x0F;
      samples[i] = (q/15)*2 - 1;
    }
  } else if(bitDepth===8){
    samples=new Float32Array(quantBytes.length);
    for(let i=0;i<quantBytes.length;i++) samples[i]=muLawByteToLinear(quantBytes[i]);
  } else if(bitDepth===12){
    const frames=Math.floor(quantBytes.length/2);
    samples=new Float32Array(frames);
    for(let i=0;i<frames;i++){
      const hi=quantBytes[i*2],lo=quantBytes[i*2+1];
      const q=((hi<<8)|lo)&0x0FFF;
      samples[i]=(q/4095)*2-1;
    }
  } else { //16-bit
    const frames=Math.floor(quantBytes.length/2);
    samples=new Float32Array(frames);
    for(let i=0;i<frames;i++){
      const hi=quantBytes[i*2],lo=quantBytes[i*2+1];
      let val=(hi<<8)|lo;
      if(val&0x8000) val-=0x10000;
      samples[i]=val<0?val/0x8000:val/0x7FFF;
    }
  }

  const audioCtx=new (window.AudioContext||window.webkitAudioContext)({sampleRate:sr});
  const buffer=audioCtx.createBuffer(1,samples.length,sr);
  buffer.copyToChannel(samples,0);
  const src=audioCtx.createBufferSource();
  src.buffer=buffer;
  src.connect(audioCtx.destination);

  /* ===== OSCILLOSCOPE ===== */
  const osc=document.getElementById('oscilloscope');
  const oscCtx=osc.getContext('2d');
  const analyser=audioCtx.createAnalyser();
  analyser.fftSize=2048;
  src.connect(analyser);
  analyser.connect(audioCtx.destination);
  const dataArray=new Uint8Array(analyser.fftSize);
  function draw(){
    requestAnimationFrame(draw);
    analyser.getByteTimeDomainData(dataArray);
    oscCtx.fillStyle='#001f1a';
    oscCtx.fillRect(0,0,osc.width,osc.height);
    oscCtx.lineWidth=1;
    oscCtx.strokeStyle='#0f0';
    oscCtx.beginPath();
    let sliceW=osc.width/dataArray.length;
    let x=0;
    for(let i=0;i<dataArray.length;i++){
      const v=(dataArray[i]-128)/128;
      const y=v*osc.height/2+osc.height/2;
      if(i===0) oscCtx.moveTo(x,y);
      else oscCtx.lineTo(x,y);
      x+=sliceW;
    }
    oscCtx.stroke();
  }
  draw();

  src.start();
  logRight(`▶️ playing ${samples.length} samples @ ${sr} Hz`);

  const wavBlob=createWavBlob(samples,sr,1);
  return {wavBlob,sr,frames:samples.length};
}

/* ================= UI wiring ================= */
document.getElementById('encodeBtn').addEventListener('click',async()=>{
  document.getElementById('logLeft').textContent='';
  const file=document.getElementById('audioInput').files[0];
  if(!file) return alert('select an audio file first');
  const bitDepth=parseInt(document.getElementById('bdSelectLeft').value,10);
  const sr=parseInt(document.getElementById('srSelectLeft').value,10);
  document.getElementById('downloadImg').style.display='none';
  try{
    const blob=await encodeAudioFileToImage(file,bitDepth,sr);
    const url=URL.createObjectURL(blob);
    const a=document.getElementById('downloadImg');
    a.href=url;a.style.display='inline';
    a.download=file.name.replace(/\.[^/.]+$/,'')+`_b${bitDepth}_sr${sr}.png`;
    a.textContent=`download image (${Math.round(blob.size/1024)} KB)`;
  }catch(e){logLeft('❌ encode error: '+e.message);console.error(e);}
});

document.getElementById('decodeBtn').addEventListener('click',async()=>{
  document.getElementById('logRight').textContent='';
  const file=document.getElementById('imageInput').files[0];
  if(!file) return alert('select an image first');
  document.getElementById('downloadWav').style.display='none';
  try{
    const {wavBlob}=await decodeImageToAudio(file);
    const url=URL.createObjectURL(wavBlob);
    const a=document.getElementById('downloadWav');
    a.href=url;a.style.display='inline';
    a.download=file.name.replace(/\.[^/.]+$/,'')+'.wav';
    a.textContent=`download wav (${Math.round(wavBlob.size/1024)} KB)`;
  }catch(e){logRight('❌ decode error: '+e.message);console.error(e);}
});

</script>
</body>
</html>
